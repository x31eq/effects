We're in trunk/src now

gx_head/gui/gx_main_window.cpp includes this comment:

This Application is to a large extent provided
with the marvelous faust compiler.Yann Orlary
(http://faust.grame.fr/)
A large part is based on the work of Julius Orion Smith
(http://ccrma.stanford.edu/realsimple/faust/)
and Albert Graef
(http://q-lang.sourceforge.net/examples.html#Faust)

The Stanford link is dead.  Old wayback machine:

https://web.archive.org/web/20080417095009/http://ccrma.stanford.edu/realsimple/faust/

Can't see anything about valves.

This looks like the current link:

https://www.dsprelated.com/freebooks/filters/Digital_Filtering_Faust_PD.html

LV2/faust/guitarix.lib has the initial parameters and some comments on valves:

thesis of Ragnar Bendiksen (used in swh ladspa valve plugin)

This was a link to that:

http://www.notam02.no/~rbendiks/Diplom/Innhold.html.

from the plugin docs

http://plugin.org.uk/ladspa-swh/docs/ladspa-swh.html#tth_sEc2.107


The Wayback Machine has it

https://web.archive.org/web/20080701141703/http://www.notam02.no/~rbendiks/Diplom/Innhold.html

in Norwegian!


LV2/gxautowah.lv2/gxautowah.ttl declares it to be a Dunlop Crybaby emulator


See also trunk/tools/ampsim/DK/README


The DK simulator uses the "DK method" and generates/compiles optimized C++ code internally
for signal calculations. it is based on the thesis
"Real-time Digital Simulation of Guitar Amplifiers as Audio Effects" by JAROMÍR MAČÁK
 (see https://www.vutbr.cz/www_base/zav_prace_soubor_verejne.php?file_id=60090)
Other useful information can be found in the thesis
"Simulation Framework for Analog Audio Circuits based on Nodal DK Method" by Piero Rivera Benois
 (see https://www.researchgate.net/publication/263013830_Simulation_Framework_for_Analog_Audio_Circuits_based_on_Nodal_DK_Method)


The Faust code generated by the DK simulator fetches only the linear behavior of a circuit.
The generated filter is an IIR filter (Infinity Impulse Response). We can only fetch
the nonlinear behavior when we generate C++ code (analog.py/Circuit.deploy())
but this code eats a lot more CPU then acceptable, hence it requires a lot of
handmade optimizations, as seen in the build_jcm800.py script.

So the recommended route is to generate the linear Faust filter and add
the nonlinear behavior as clipping table. Therefore the circuit is split into pieces.
For the case of the FuzzFaceJH1 for example, the P2 Volume pot is replaced by a 1000k resistor
and the output set above it, so the circuit runs on full level.
Then the MPSA18_table.h is generated from the trany_table-gen.py script and added into the source folder.


That script is really

tools/ampsim/DK/scripts/build-jcm800-preamp.py
